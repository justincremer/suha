use std::io;
use std::sync::mpsc::{Receiver, Sender};
use std::{sync::mpsc, thread};

use termion::event::Event;
use termion::input::TermRead;

#[derive(Debug, Clone)]
pub enum RuntimeEvent {
    Termion(Event),
    Signal(i32),
    Tick,
}

#[derive(Debug)]
pub struct EventHandler {
    pub event_tx: Sender<RuntimeEvent>,
    pub event_rx: Receiver<RuntimeEvent>,
}

impl EventHandler {
    pub fn new() -> Self {
        let (event_tx, event_rx) = mpsc::channel::<RuntimeEvent>();
        Self { event_tx, event_rx }
    }

    pub fn spawn(&self) {
        let event_txc = self.event_tx.clone();
        thread::spawn(move || {
            let stdin = io::stdin();
            let mut events = stdin.events();
            match events.next() {
                Some(event) => match event {
                    Ok(event) => {
                        if let Err(e) = event_txc.send(RuntimeEvent::Termion(event)) {
                            eprintln!("Input thread send err: {:#?}", e);
                            return;
                        }
                    }
                    Err(_) => return,
                },
                None => return,
            }
        });
    }

    pub fn next(&self) -> Result<RuntimeEvent, mpsc::RecvError> {
        Ok(self.event_rx.recv()?)
    }

    // pub fn
}

// fn handle_key_event(rx: &Receiver<KeyEvent>) {
//     match rx.recv()? {
//         Key::Char('q') => tx.send(KeyEvent::Exit(0)).expect("can send events"),
//         Key::Ctrl(c) => {
//             if c == 'c' || c == 'C' {
//                 tx.send(KeyEvent::Exit(0)).expect("can send events")
//             }
//         }
//         _ => {} // KeyEvent::Exit(code) =>
//     }
// }
